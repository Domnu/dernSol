########## H:\dernSol\chat\middleware.py ##########

from django.contrib.auth import login
from django.utils.deprecation import MiddlewareMixin
from chat.models import MyUser
import logging

logger = logging.getLogger(__name__)

class AutoLoginMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        if not request.user.is_authenticated:
            try:
                # Remplacez 'guy' par le nom d'utilisateur que vous souhaitez utiliser
                user = MyUser.objects.get(username='guy')
                login(request, user)
            except MyUser.DoesNotExist:
                logger.error('MyUser with username "guy" does not exist.')
                # Vous pouvez ajouter une logique pour gérer le cas où l'utilisateur n'existe pas
        response = self.get_response(request)
        return response


class SomeMiddleware(MiddlewareMixin):
    def __call__(self, request):
        username = 'guy'  # Remplacez par la logique pour obtenir le nom d'utilisateur
        try:
            user = MyUser.objects.get(username=username)
        except MyUser.DoesNotExist:
            user = None
            logger.error(f'MyUser with username "{username}" does not exist.')
            # Ajoutez une logique pour gérer le cas où l'utilisateur n'existe pas
        request.user = user
        response = self.get_response(request)
        return response


########## H:\dernSol\dernSol\settings.py ##########

"""
Django settings for dernSol project.

Generated by 'django-admin startproject' using Django 5.0.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

# dernSol/settings.py

import os
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'your-secret-key'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True
# DEBUG = False

ALLOWED_HOSTS = ['localhost', '127.0.0.1']
# ALLOWED_HOSTS = ['*']

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'chat.apps.ChatConfig',
    "accounts.apps.AccountsConfig"  # Your main application
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'dernSol.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'dernSol.wsgi.application'

# Database
# https://docs.djangoproject.com/en/3.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Password validation
# https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/3.2/topics/i18n/

# Set the language code to French (Belgium)
LANGUAGE_CODE = 'fr-be'

# Set the time zone to Brussels
TIME_ZONE = 'Europe/Brussels'

USE_I18N = True

USE_L10N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.2/howto/static-files/

STATIC_URL = '/static/'

STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]

# Default primary key field type
# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# Custom user model if applicable
AUTH_USER_MODEL = 'accounts.CustomUser'

"""
NB:
N'oubliez pas que les paramètres des environnements de développement et de production 
doivent être séparés. Ce code semble plus adapté à l'environnement de développement. 
N'oubliez pas non plus d'exclure les données sensibles du contrôle de version en 
utilisant des variables d'environnement ou des fichiers de configuration externes.
================================================================================
Définissez une variable d'environnement nommée DJANGO_SECRET_KEY avec une valeur unique et imprévisible. Vous pouvez le faire dans les paramètres des variables d'environnement de votre système d'exploitation ou dans le script de profil de votre shell.
Dans votre fichier de paramètres Django, utilisez la fonction os.getenv() pour obtenir la valeur de la variable d'environnement DJANGO_SECRET_KEY, comme ceci :

import os

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv('DJANGO_SECRET_KEY')
Enregistrez vos modifications et redémarrez votre serveur de développement Django.
Rappelez-vous, la variable SECRET_KEY doit être gardée secrète et ne pas être partagée publiquement. Il est également recommandé d'utiliser des valeurs SECRET_KEY différentes pour les environnements de développement et de production.
"""

########## H:\dernSol\accounts\models.py ##########

# chat/accounts/models.py

from django.contrib.auth.models import AbstractUser
from django.db import models


class CustomUser(AbstractUser):
    followers = models.ManyToManyField('self', symmetrical=False, related_name='following')


########## H:\dernSol\chat\models.py ##########

from django.conf import settings
from django.db import models
from django.urls import reverse


class Article(models.Model):
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='articles')
    title = models.CharField(max_length=200)
    body = models.TextField()
    image = models.ImageField(upload_to='articles/', blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    likes = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='liked_articles', blank=True)

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        return reverse('chat:article_detail', kwargs={'pk': self.pk})

    # Suggestion: Method to count likes
    def total_likes(self):
        return self.likes.count()


class Comment(models.Model):
    article = models.ForeignKey(Article, on_delete=models.CASCADE, related_name='comments')
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    title = models.CharField(max_length=100, blank=True, null=True)
    body = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    parent = models.ForeignKey('self', null=True, blank=True, related_name='replies', on_delete=models.CASCADE)

    def __str__(self):
        return f'Comment by {self.author} on {self.article}'

    # Suggestion: Method to check if a comment has replies
    def has_replies(self):
        return self.replies.exists()

    # Suggestion: Method to get the number of replies
    def total_replies(self):
        return self.replies.count()


# chat/models.py

class Notification(models.Model):
    recipient = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='notifications')
    message = models.TextField()
    is_read = models.BooleanField(default=False)
    timestamp = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.message


# chat/models.py

class PrivateMessage(models.Model):
    sender = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='sent_messages', on_delete=models.CASCADE)
    recipient = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='received_messages', on_delete=models.CASCADE)
    body = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)
    is_read = models.BooleanField(default=False)

    def __str__(self):
        return f'Message from {self.sender} to {self.recipient}'


########## H:\dernSol\chat\urls.py ##########

from django.urls import path
from .views import Index, signup, ArticleListView, ArticleDetailView, ArticleCreateView, CommentCreateView, add_comment, \
    article_like, page_404_test, mark_notification_as_read, notifications

app_name = 'chat'

urlpatterns = [
    path('', Index, name='index'),
    path('signup/', signup, name='signup'),
    path('articles/', ArticleListView.as_view(), name='article_list'),
    path('articles/<int:pk>/', ArticleDetailView.as_view(), name='article_detail'),
    path('articles/create/', ArticleCreateView.as_view(), name='article_create'),
    path('articles/<int:pk>/comment/', CommentCreateView.as_view(), name='comment_create'),
    path('articles/<int:pk>/add_comment/', add_comment, name='add_comment'),
    path('articles/<int:pk>/like/', article_like, name='article_like'),
    path('page_404/', page_404_test, name='page_404'),
path('notifications/', notifications, name='notifications'),
    path('notifications/mark-as-read/<int:notification_id>/', mark_notification_as_read, name='mark_notification_as_read'),
]

handler404 = 'chat.views.custom_404'


########## H:\dernSol\chat\views.py ##########

from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.http import Http404
from django.shortcuts import get_object_or_404, render, redirect
from django.urls import reverse
from django.views.decorators.http import require_POST
from django.views.generic import ListView, DetailView, CreateView

from .forms import ArticleForm, CommentForm
from .models import Article, Comment

from django.shortcuts import render

from django.contrib.auth import get_user_model
User = get_user_model()


def page_404_test(request):
    response = render(request, 'chat/page_404.html', {})
    response.status_code = 404
    return response


def custom_404(request, exception):
    return render(request, '404.html', {}, status=404)


def Index(request):
    return render(request, 'chat/index.html')


def signup(request):
    return render(request, 'chat/signup.html')


class ArticleListView(ListView):
    model = Article
    template_name = 'chat/article_list.html'
    context_object_name = 'article_list'

    def get_queryset(self):
        return Article.objects.select_related('author').all()


class ArticleDetailView(DetailView):
    model = Article
    template_name = 'chat/article_detail.html'
    context_object_name = 'article'

    def get_queryset(self):
        return Article.objects.select_related('author').prefetch_related('comments')

    def get_object(self, queryset=None):
        try:
            obj = super().get_object(queryset)
            return obj
        except Article.DoesNotExist:
            print("Lin 41 views.py - Article does not exist!")  # Ajouter cette ligne pour le débogage
            raise Http404("No Article matches the given query.")

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['comments'] = Comment.objects.filter(article=self.object)
        return context


class ArticleCreateView(LoginRequiredMixin, CreateView):
    model = Article
    form_class = ArticleForm
    template_name = 'chat/article_form.html'

    def form_valid(self, form):
        form.instance.author = self.request.user
        response = super().form_valid(form)
        followers = self.request.user.followers.all()
        for follower in followers:
            Notification.objects.create(
                recipient=follower,
                message=f'{self.request.user.username} a publié un nouvel article : "{self.object.title}".'
            )
        return response


@login_required
def article_like(request, pk):
    article = get_object_or_404(Article, pk=pk)
    if request.user.is_authenticated:
        if request.user in article.likes.all():
            article.likes.remove(request.user)
        else:
            article.likes.add(request.user)
    return redirect('chat:article_detail', pk=pk)


class CommentCreateView(LoginRequiredMixin, CreateView):
    model = Comment
    form_class = CommentForm
    template_name = 'chat/comment_form.html'

    def form_valid(self, form):
        form.instance.article = get_object_or_404(Article, pk=self.kwargs['pk'])
        form.instance.author = self.request.user
        response = super().form_valid(form)
        Notification.objects.create(
            recipient=self.object.article.author,
            message=f'New comment on your article "{self.object.article.title}" by {self.request.user.username}'
        )
        if form.instance.parent:
            Notification.objects.create(
                recipient=form.instance.parent.author,
                message=f'{self.request.user.username} a répondu à votre commentaire.'
            )
        return response

    def get_success_url(self):
        article_id = self.object.article.pk
        return reverse('chat:article_detail', kwargs={'pk': article_id})

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        article_id = self.kwargs.get('pk')
        context['article'] = get_object_or_404(Article.objects.select_related('author'), pk=article_id)
        return context


@login_required
@require_POST
def add_comment(request, pk):
    article = get_object_or_404(Article, pk=pk)
    form = CommentForm(request.POST)
    if form.is_valid():
        comment = form.save(commit=False)
        comment.article = article
        comment.author = request.user  # Assurez-vous que l'utilisateur est authentifié
        comment.save()
    return redirect('chat:article_detail', pk=article.pk)


from .forms import PrivateMessageForm
from .models import PrivateMessage


@login_required
def inbox(request):
    messages = PrivateMessage.objects.filter(recipient=request.user).order_by('-timestamp')
    return render(request, 'chat/inbox.html', {'messages': messages})


@login_required
def send_message(request):
    if request.method == 'POST':
        form = PrivateMessageForm(request.POST)
        if form.is_valid():
            private_message = form.save(commit=False)
            private_message.sender = request.user
            private_message.save()
            return redirect('chat:inbox')
    else:
        form = PrivateMessageForm()
    return render(request, 'chat/send_message.html', {'form': form})


from .models import Notification


@login_required
def notifications(request):
    user_notifications = Notification.objects.filter(recipient=request.user, is_read=False)
    return render(request, 'chat/notifications.html', {'notifications': user_notifications})


@login_required
def mark_notification_as_read(request, notification_id):
    notification = get_object_or_404(Notification, pk=notification_id, recipient=request.user)
    notification.is_read = True
    notification.save()
    return redirect('chat:notifications')
